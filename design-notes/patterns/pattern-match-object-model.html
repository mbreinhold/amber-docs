<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>pattern-match-object-model</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
      <style type="text/css">
        A IMG { border-width: 0px; }
  
        BODY {
            background: white;
            margin: 2em;
          font-size: medium;
          max-width: 60em;
          margin-bottom: 100%;
          font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji;
        }
  
        code, pre, tt {
  	font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
  	font-size: medium
        }
  
        code {
            display: inline-block;
            padding: .1em .2em;
          font-size: 90%;
          border-radius: 6px;
  	background-color: #f6f8fa;
          box-sizing: border-box;
        }
  
        h1 {
  	  font-size: 32px;
        }
  
        h1,
        h2 {
  	  font-weight: 600;
            border-bottom: 1px solid #e8e8e8;
        }
        
        h2 {
  	  font-size: 24px
        }
        
        h3 {
  	  font-size: 20px
        }
        
        h3,
        h4 {
  	  font-weight: 600
        }
        
        h4 {
  	  font-size: 20px
        }
  
        P { margin: 1ex 0em; }
        P.subsection { margin-top: 2ex; }
        P.subsection:first-child { margin-top: 1ex; }
        P SPAN.title { font-weight: bold; padding-right: 1em; }
  
        PRE {
          margin: 1.5ex 2em;
          padding: 1px 1ex;
          background: #f6f8fa;
        }
  
        .sidebar {
          margin: 1.5ex 2em;
          padding: 1px 1ex;
          background: #e8e8e8;
        }
  
        .control-character {
            color: #bbb;
            font-style: italic;
        }
  
        /* added for ```{.jvm} support */
        PRE.jvm { font-style: italic; }
  
        BLOCKQUOTE { margin: 1.5ex 2em; font-style: italic; border-left: 0.2em solid gray; padding-left: 1em; }
        LI BLOCKQUOTE { margin-left: 0em; }
        LI { margin: 0ex 0em; }
  
        TABLE, TH, TD { border: 1px solid #e8e8e8;
                        padding: 6px 12px; }
        TR:nth-child(2n) {
            background-color: #f6f8fa;
        }
        TH { font-weight: 600 }
        TABLE { border-collapse: collapse; }
        TD { vertical-align: top; }
  
        UL LI { list-style-type: square; }
  
        DIV.summary { margin: 2ex 2em; }
  
        DIV.head { margin-bottom: 2em; }
        DIV.doctitle { font-size: x-large; font-weight: bold; }
        DIV.twarn { color: #cc0000; font-size: smaller; font-weight: bold;
                    margin-bottom: 1.5ex; }
        DIV.authors { margin-top: 1ex; font-size: large; }
        DIV.author A { font-style: italic; }
        DIV.version { font-size: medium; margin-top: 1ex; }
        DIV.copyright, DIV.comments { font-size: small; }
        DIV.version SPAN.modified { color: green; font-weight: bold; }
        DIV.head DIV.notes { margin-top: 1ex; }
        DIV.qa { margin-top: 2ex; }
        DIV.footer { padding-top: 4em; text-align: center; font-size: 7pt; }
        
        /* added because pandoc syntax highlighting always uses scroll bars */
        DIV.sourceCode {
            overflow: visible;
        }
  
        HR { border: 0px; border-top: 1px solid black; margin: 2ex 0em; }
     </style>
</head>
<body>
<h1 id="pattern-matching-in-the-java-object-model">Pattern Matching in the Java Object Model</h1>
<h4 id="brian-goetz-and-gavin-bierman" class="author">Brian Goetz and Gavin Bierman</h4>
<h4 id="december-2020" class="date">December 2020</h4>
<p>This document describes a possible approach for how <em>pattern matching</em> might be integrated more deeply into the language. <em>This is an exploratory document only and does not constitute a plan for any specific feature in any specific version of the Java Language.</em></p>
<h3 id="pattern-matching-documents">Pattern matching documents</h3>
<ul>
<li><a href="pattern-matching-for-java">Pattern Matching For Java</a>. Overview of pattern matching concepts, and how they might be surfaced in Java.</li>
<li><a href="pattern-match-semantics">Pattern Matching For Java – Semantics</a>. More detailed notes on type checking, matching, and scoping of patterns and binding variables.</li>
<li><a href="extending-switch-for-patterns">Extending Switch for Patterns</a>. An early exploration of the issues surrounding extending pattern matching to the <code>switch</code> statement.</li>
<li><a href="type-patterns-in-switch">Type Patterns in Switch</a>. A more up-to-date treatment of extending pattern matching to <code>switch</code> statements, including treatment of nullity and totality.</li>
<li><a href="pattern-match-object-model">Pattern Matching in the Java Object model</a> (this document). Explores how patterns fit into the Java object model, how they fill a hole we may not have realized existed, and how they might affect API design going forward.</li>
</ul>
<h2 id="why-pattern-matching">Why pattern matching?</h2>
<p>The related documents offered numerous examples of how pattern matching makes common code constructs simpler and less error-prone. These may be enough reason on their own to want to add pattern matching to Java, but we believe there is also a deeper reason to go there: that it fills in a hole in the object model, and one we might not have even realized we were missing.</p>
<h3 id="recap-what-is-pattern-matching">Recap – what is pattern matching?</h3>
<p>Readers who are unfamiliar with pattern matching should first read the above-referenced documents, but to summarize: pattern matching fuses three operations that are commonly done together: an <em>applicability test</em>, zero or more <em>conditional extractions</em> if the test succeeds, and <em>binding</em> the extracted results to fresh variables. A pattern match like:</p>
<pre><code>if (p instanceof Point(int x, int y)) { ... }</code></pre>
<p>expresses all three of these things in one go – it asks if the target is a <code>Point</code>; if it is, casts it to <code>Point</code> and extracts its <code>x</code> and <code>y</code> coordinates; and binds these to the variables <code>x</code> and <code>y</code>.</p>
<h3 id="aggregation-and-destructuring">Aggregation and destructuring</h3>
<p>Object-oriented languages provide many facilities for <em>aggregation</em>; the <a href="https://en.wikipedia.org/wiki/Design_Patterns">Gang of Four</a> book defines several patterns for object creation (e.g., Factory, Singleton, Builder, Prototype). Object creation is so important that languages frequently include specific features corresponding to these patterns. Aggregation allows us to abstract data from the specific to the general, but recovering the specifics when we need them is often difficult and ad-hoc. For example, it is common to provide factory methods for particular specific configurations of aggregates, and these factories typically return an abstract type, such as:</p>
<pre><code>static Shape redBall(int radius) { ... }
static Shape redCube(int edge) { ... }</code></pre>
<p>At the invocation site, it is obvious what kind of shape is being created, but once we start passing it around as a <code>Shape</code>, it can be harder to recover its properties. Sometimes we reflect some of the properties in the type system (such as concrete subtypes of <code>Shape</code> for <code>Ball</code> and <code>Cube</code>), but this is not always practical (especially when state is mutable). Other times, APIs expose accessors for these properties (such as a <code>shapeKind()</code> method on <code>Shape</code>), but attempting to distill a least-common-denominator set of properties on an abstract type is often a messy modeling exercise. (For example, should a <code>size()</code> method correspond to the edge size for a cube and the radius of a ball, or should it attempt to normalize sizes somehow? Or, should we have partial methods like <code>ballRadius()</code> which fail when you apply them to a cube?) In this approach, clients must be aware of how factories map their parameters to abstract properties, which is complex and error-prone. <em>Destructuring</em> provides this missing ability to recover the specific from the abstract more directly.</p>
<blockquote>
<p><em>Destructuring is the dual of aggregation.</em></p>
</blockquote>
<p>Java provides direct linguistic support for aggregation, in the form of <em>constructors</em> that take a description of an object’s initial state and aggregates it into an instance, but does not directly provided the reverse. Instead, we leave that problem to APIs, which may expose accessors for individual state components, and those accessors may or may not map to the arguments presented to constructors or factories. But this is a poor approximation for all but the simplest classes, because the code for aggregation and for destructuring often operate at different levels of granularity, and look structurally different – and these differences provide places for bugs to hide. Whatever tools the language offers us for aggregation (e.g., constructors, factories, builders), it should also offer us complementary destructuring, ideally that is syntactically similar in declaration and use, and operate at the same level of abstraction. For example, if our <code>Shape</code> library provided factories like the above, it could provide destructuring patterns that are similar in name and structure:</p>
<pre><code>switch (shape) {
    case Shape.redBall(var radius): ...
    case Shape.redCube(var edge): ...
}</code></pre>
<blockquote>
<p><em>Enabling API designers to provide complementary destructuring operations for their aggregation operations enables more reversible APIs while still allowing the API to mediate access to encapsulated state.</em></p>
</blockquote>
<p>Of course, there may be some aggregates that don’t want to give up their state, and that’s fine. The goal is not to force transparency on all classes, but instead to give API designers the tools with which to expose destructuring operations that are structurally similar to its aggregation operations, should they so desire. Many, but not all, APIs would benefit from this.</p>
<h3 id="object-creation-in-java">Object creation in Java</h3>
<p>The most common idioms for creating objects in Java are constructors, factories, and builders. Constructors are a language feature; factories and builders are design patterns implemented by libraries. A specific API typically prefers one of these idioms; either it exposes constructors, or hides the constructors and provides factories, or hides the constructors and provides builders.</p>
<p>A sufficiently rich pattern matching facility would allow API designers to provide complementary destructuring facilities for each of these idioms, which leads to more readable and less error-prone client code. If an object is created with a constructor:</p>
<pre><code>Object x = new Foo(a, b);</code></pre>
<p>ideally, it should be destructurable via a “deconstruction pattern”:</p>
<pre><code>case Foo(var a, var b): ...</code></pre>
<p>The syntactic similarity between the construction and deconstruction is not accidental; appealing to a constructor-like syntax allows the user to see this as asking “if x could have come into existence by invoking the <code>Foo(a, b)</code> constructor, what values of <code>a</code> and <code>b</code> would have been provided?”</p>
<p>Similarly, if an object is created with a static factory:</p>
<pre><code>Object x = Foo.of(a, b);</code></pre>
<p>ideally, it should be destructurable via a “static pattern”:</p>
<pre><code>case Foo.of(var a, var b): ...</code></pre>
<p>As a more concrete example, we construct <code>Optional</code> instances with:</p>
<pre><code>o = Optional.of(x);
o = Optional.empty();</code></pre>
<p>so we should be able to discriminate between <code>Optional</code> instances via static patterns:</p>
<pre><code>case Optional.empty(): ...
case Optional.of(var x): ...</code></pre>
<p>(with bonus points if we can make the combination of these two patterns <em>total</em> on non-null instances of <code>Optional</code>.)</p>
<h3 id="composition">Composition</h3>
<p>Another aspect in which we would like destructuring to mirror aggregation is in <em>composition</em>. Suppose, in our <code>Shape</code> example, we put a unit-sized red ball in an <code>Optional</code>:</p>
<pre><code>Optional&lt;Shape&gt; os = Optional.of(Shape.redBall(1));</code></pre>
<p>The creational idioms we use – here, static factories – compose, allowing us to express this compound creation clearly and concisely.</p>
<p>To determine if an <code>Optional&lt;Shape&gt;</code> could have derived from the above action, using the sorts of APIs we have today, we would have to do something like:</p>
<pre><code>Shape s = os.orElse(null);
boolean isRedUnitBall = s != null
                       &amp;&amp; s.isBall()
                       &amp;&amp; (s.color() == RED)
                       &amp;&amp; s.size() == 1;
if (isRedUnitBall) { ... }</code></pre>
<p>The code to take apart the <code>Optional&lt;Shape&gt;</code> looks nothing like the code to create it, and is significantly more complicated – which means it is harder to read and harder to get right. (As evidence of this, the first draft of this example had a subtle mistake, which wasn’t caught until review!) And, as we compose more deeply, these differences can multiply. On the other hand, if <code>Optional</code> and <code>Shape</code> provided complementary destructuring APIs to their creation APIs, we could compose these just as we did with aggregation:</p>
<pre><code>if (os instanceof Optional.of(Shape.redBall(var size))
    &amp;&amp; size == 1) { ... }</code></pre>
<p>This will match an <code>Optional</code> that contains a red ball of unit radius, regardless of how it was created.</p>
<blockquote>
<p><em>First-class destructuring leads to composable APIs.</em></p>
</blockquote>
<p>Method invocations compose from the inside out; pattern matching, which works like a method invocation in reverse, composes from the outside in. A nested pattern</p>
<pre><code>if (os instanceof Optional.of(Shape.redBall(var size)) { ... }</code></pre>
<p>simply means</p>
<pre><code>if (os instanceof Optional.of(var alpha)
    &amp;&amp; alpha instanceof Shape.redBall(var size)) { ... }</code></pre>
<p>where <code>alpha</code> is a synthetic variable. We apply the outer pattern, and, if it matches, we apply the inner patterns to the resulting bindings.</p>
<p>We might still like to get rid of the boolean expression <code>size == 1</code>; this can be handled as a nested <em>constant pattern</em>, should we decide to support them. This might look like (illustrative syntax only):</p>
<pre><code>if (os instanceof Optional.of(Shape.ofRedBall(== 1))) { ... }</code></pre>
<p>where <code>== c</code> is a constant pattern that matches the constant <code>c</code>.</p>
<h3 id="isnt-this-just-multiple-return">Isn’t this just multiple return?</h3>
<p>It may appear at first that patterns – which can “return” multiple values to their “callers” – are really just methods with multiple return values, and that if we had multiple return (or tuples, or “out” parameters), we wouldn’t need patterns. But bundling return values is only half of the story.</p>
<p>What’s going on here is more subtle; the production of the multiple “return values” is <em>conditional</em> on some other calculation, and this conditional relationship – that the bindings are only valid if the match succeeds – is understood by the language (and can be incorporated into control flow analysis through definite assignment.)</p>
<p>The conditionality of pattern bindings enables a more sophisticated scoping of pattern variables, which in turn enables patterns to compose more cleanly than simple multi-return method calls. The “unit red ball” example above illustrates what happens when the language can’t reason for us about under what conditions a variable is assigned; we would have to make up the difference with explicit control flow logic (e.g., <code>if</code>), that grows more complex and error-prone the more deeply we try to combine conditions.</p>
<h3 id="patterns-as-api-points">Patterns as API points</h3>
<p>One does not need to look very far to see the amount of work we expend working around the lack of a first-class destructuring mechanism; we’re so used to doing it that we don’t even notice. Consider the following two methods from <code>java.lang.Class</code>:</p>
<pre><code>boolean isArray() { ... }
Class&lt;?&gt; getComponentType() { ... }</code></pre>
<p>The latter method is partial, and should only be called when the former method returns <code>true</code>; this means that the author has to specify the precondition, specify what happens if the precondition is not met, check for the precondition in the implementation, and take the corresponding failure action (return <code>null</code>, throw an exception, etc.) Similarly, the client has to make two calls to get the desired quantity, and therefore has more chance to get it wrong (to say nothing of race conditions). This is the worst of all worlds – more work for the library author, more work for the client, and more risk of subtle bugs. These two methods really should be one operation, which simplifies life for both the library and client:</p>
<pre><code>if (c instanceof Class.arrayClass(var componentType)) { ... }</code></pre>
<p>Now the library need expose only one API point, the client can’t misuse it, and the act-before-check bug is impossible.</p>
<blockquote>
<p><em>First-class destructuring leads to APIs that are harder to misuse.</em></p>
</blockquote>
<h3 id="data-driven-polymorphism">Data-driven polymorphism</h3>
<p>Java offers several mechanisms for polymorphism; <em>parametric polymorphism</em> (generics), where we can share code across a family of instantiations that vary only by type, and <em>inclusion polymorphism</em> (subtyping), where we can share an <em>API</em> across a family of instantiations that differ more broadly. These are effective tools for modeling a lot of things, but sometimes we want to express commonality between entities with some similar property, without needing to reflect it in the type system. Pattern matching allows us to easily express <em>ad-hoc</em>, or <em>data-driven</em> polymorphism. One can easily pattern match over a number of unrelated types or structures if needed.</p>
<p>Supporting ad-hoc polymorphism with pattern matching doesn’t mean that inheritance hierarchies and virtual methods are wrong – it’s just that this is not the only useful way to attack a problem. Sometimes, using the hierarchy is the natural way to express what we mean, but sometimes it is not, and sometimes it is not even possible, such as when an endpoint listens for a variety of messages, and not all message types have a common supertype (or even come from the same library.) In these cases, pattern matching offers clean and simple data-driven polymorphism.</p>
<h2 id="patterns-as-class-members">Patterns as class members</h2>
<p>In languages with structural aggregate types (e.g., tuples and maps), aggregation and destructuring are simple, well-defined, built-in operations – because these aggregate types are just transparent wrappers for their data. In object-oriented languages like Java, aggregation operations are expressed in imperative code, which can use arbitrary logic to validate the arguments and construct the aggregate from the inputs.</p>
<p>For certain well-behaved classes – those whose representation is sufficiently coupled to their API – it may be possible to derive deconstruction logic without explicit imperative code. One category of classes whose state is trivially and transparently coupled to its API are <a href="../records-and-sealed-classes"><em>records</em></a>, and these will acquire destructuring patterns automatically, just as they do with constructors.</p>
<p>In other cases, someone is going to have to write some code to describe how to map the representation to the external deconstruction API, just as constructors imperatively map the invocation arguments to the representation. So there is going to be some code somewhere which captures the applicability test and the mapping between target state and the pattern’s binding variables – and the natural place to put that code is in the same class as the constructor or factory.</p>
<blockquote>
<p><em>Patterns are executable class members.</em></p>
</blockquote>
<h3 id="anatomy-of-a-pattern">Anatomy of a pattern</h3>
<p>In a pattern match like:</p>
<pre><code>if (p instanceof Point(int x, int y)) { ... }</code></pre>
<p>the pattern has a <em>name</em> (<code>Point</code>), a <em>target operand</em> (<code>p</code>), and zero or more <em>binding variables</em> (<code>x</code> and <code>y</code>). For a deconstruction pattern like this, the applicability test is simple and transparent – is the target an instance of the class <code>Point</code>. But we can have patterns with more sophisticated applicability tests, such as “does this <code>Optional</code> contain a value” or “does this <code>Map</code> contain a mapping for a given key.”</p>
<h3 id="deconstruction-patterns">Deconstruction patterns</h3>
<p>A simple form of pattern is the dual of construction. A constructor takes zero or more state elements and produces an aggregate; the reverse starts with an aggregate and produces corresponding state elements. (If the term “destructor” were not already burdened by its resource-release association from <code>C++</code>, we’d likely call it that; instead we’ll describe this form of pattern as a <em>deconstructor</em> or <em>deconstruction pattern</em>.)</p>
<p>For a deconstruction pattern, there is an obvious way to describe and reference the target operand – the receiver. And there is an obvious way to declare the arity, type, and order of the binding variables – as a parameter list. This <em>might</em> look something like:</p>
<pre><code>class Point {
    int x, y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public deconstructor(int x, int y) {
        x = this.x;
        y = this.y;
    }
}</code></pre>
<p>The duality between constructor and deconstructor is manifest in multiple ways:</p>
<ul>
<li><p><strong>Use site syntax.</strong> Invoking a constructor, and invoking a deconstructor through a pattern match, bear a deliberate syntactic similarity: we construct a <code>Point</code> via its constructor <code>new Point(x, y)</code>, and we deconstruct a <code>Point</code> with the deconstruction pattern <code>Point(int x, int y)</code>.</p></li>
<li><p><strong>Invocation shape.</strong> The constructor arguments and deconstructor bindings have the same names and types. The argument list for the constructor describes its inputs, and the binding variable list for the deconstructor describes its outputs – and they are the same, describing the <em>external</em> state of the object.</p></li>
<li><p><strong>Behavior and body.</strong> The constructor copies values from the arguments to the object state, and the deconstructor copies values from the object state to the binding variables. And, just as the constructor is free to perform defensive copying on the inputs, the deconstructor may wish to do the same with the outputs (perhaps delegating to a getter, if one is available.)</p></li>
<li><p><strong>Invocation and inheritance.</strong> Constructors are an unusual hybrid of instance and static behavior – they are instance members, but are invoked statically and not inherited. Deconstructors are the same.</p></li>
</ul>
<h3 id="method-patterns">Method patterns</h3>
<p>Since patterns are class members, let’s enumerate some of the degrees of freedom that methods have, and ask if they make sense for patterns as well. (The final design may or may not incorporate all of these aspects, but the intent of this section is to show that the tools we use for modeling existing class members extend equally well to patterns.)</p>
<ul>
<li><p><strong>Does it make sense to have accessibility modifiers on pattern declarations?</strong> Yes! For example, we routinely declare protected constructors for use by subclasses in implementing their own constructors. In exactly the same way, protected deconstructors can be used by subclasses in implementing their own deconstructors. And, just as we use private or package-private constructors to restrict who can instantiate an object, we can use private or package-private deconstructors to restrict who can take an instance apart and access its state.</p></li>
<li><p><strong>Does pattern overloading make sense?</strong> Yes! Just as we may want to provide multiple overloads of a constructor, each with different descriptions of an object’s state, we may want to provide corresponding overloads of deconstructors to mirror the state descriptions accepted by the various constructors.</p></li>
<li><p><strong>Do static patterns make sense?</strong> Yes! Just as some APIs expose static factories rather than constructors, it also makes sense to expose static patterns as the dual of these static factories. For example, the factory method <code>Optional.of(t)</code> takes a <code>T</code> and wraps it in an <code>Optional</code>; a corresponding static pattern would take an <code>Optional&lt;T&gt;</code> and deconstruct it, conditionally, giving up the contained value, and fail to match when the target <code>Optional</code> is empty.</p>
<p>Static methods have another advantage, which is that they can be declared outside of the relevant class – and the same is true of static patterns. Just as a class can expose a static factory for an unrelated class, a class can also expose a static pattern for another class (as long as the relevant state is accessible to the implementation of the pattern). So, if the <code>Optional</code> class failed to provide suitable patterns for deconstructing its instances, these could still be provided by an unrelated library. Similarly, APIs that use “sidecar” classes like <code>Collections</code> to hold factories, can put patterns there as well.</p></li>
<li><p><strong>Do generic patterns make sense?</strong> Yes! Static factories are often generic methods, such as <code>Optional::of</code>; these generic type parameters can be used to express type constraints on the signature. The same is true for patterns.</p></li>
<li><p><strong>Do instance patterns make sense?</strong> Yes! Just as instance methods allow a supertype to define the API and for subtypes to define the implementation, the same can be done with patterns. Like deconstruction patterns, instance patterns implicitly use the receiver as the target to be matched. A pattern on <code>Map</code> for “does the map contain this key” would be an instance pattern, for example – and each <code>Map</code> implementation might want to provide its own implementation for this.</p>
<p>An API idiom that might make use of instance patterns are the dual of <em>builders</em>. Builders accept a sequence of calls to add content or set properties on the object being built. To deconstruct an object that has been built in this manner, we can define an <em>unbuilder</em>, which could iterate through the structure of the object, and expose various patterns (likely corresponding to the builder methods) for “does the current item have this structure”. This allows the API developer to expose a rich deconstruction API without having to make the structure directly accessible, or copy the data to another format.</p></li>
<li><p><strong>Do abstract patterns make sense?</strong> Yes! An interface such as <code>Map</code> may want to expose a pattern which matches a <code>Map</code> which has a certain key, and if so, binding the corresponding value, and leave the implementation to concrete subtypes.</p></li>
<li><p><strong>Does overriding patterns make sense?</strong> Yes! A skeletal implementation such as <code>AbstractMap</code> could provide a least-common-denominator implementation of a pattern, allowing concrete subtypes to override it.</p></li>
<li><p><strong>Do varargs patterns make sense?</strong> Yes! Consider a method like <code>String::format</code>, which takes a format string and a varargs of <code>Object...</code> arguments to be substituted into the string:</p>
<pre><code>String s = String.format(&quot;%s is %d years old&quot;, name, age);</code></pre>
<p>To reverse the encoding from data to string, we might want to expose a complementary pattern, which exposes an <code>Object...</code> of extracted values – which can be refined further by pattern composition:</p>
<pre><code>if (s instanceof String.format(&quot;%s is %d years old&quot;,
                               String name, Integer.valueOf(int age))) {
    ...
}</code></pre></li>
<li><p><strong>Does it make sense for patterns to delegate to other patterns?</strong> Yes! Just as constructors delegate to other constructors via <code>this()</code> or <code>super()</code>, we expect that patterns will also want to delegate to other patterns to bind a subset of their binding variables – and we want it to be easy to do so.</p></li>
</ul>
<p>It should not be surprising that all the degrees of freedom that make sense for constructors and methods, also make sense for patterns – because they describe complementary operations.</p>
<h3 id="additional-degrees-of-freedom">Additional degrees of freedom</h3>
<p>There are also some characteristics that are applicable to patterns but not to constructors or methods, and these influence how we might declare patterns in source code.</p>
<ul>
<li><p><strong>Targets and applicability.</strong> Patterns have a <em>target</em> operand, which is the instance against which the pattern will be matched. They also have a static <em>target type</em>; if the static type of the operand is not cast-convertible to the target type, the pattern cannot match. For a type pattern <code>T t</code> or a deconstruction pattern <code>T(...)</code>, the target type is <code>T</code>; for a static pattern such as <code>Optional::of</code>, the target type is <code>Optional</code>. For deconstruction / instance patterns, the target type is the receiver. (For static patterns, the target type must be explicitly specified somehow as part of its declaration, along with some way of denoting a reference to the target.)</p></li>
<li><p><strong>Totality vs partiality.</strong> Some patterns are <em>total</em> on their target type, meaning that all (non-null) instances of that type will match the pattern; type patterns and deconstruction patterns are total in this way. Others are <em>partial</em>, where not only must the target be of a certain type, but it also must satisfy some predicate; <code>Optional.of(T t)</code> is such a pattern (it doesn’t match anything that is not an <code>Optional</code>, but it further requires it to be non-empty.) If totality is a property of a pattern declaration, not just its implementation, then the compiler can reason about when it can guarantee a match (and thus not require some sort of unreachable <code>else</code> logic.) For partial patterns, there must also be some way for the declaration to indicate a failure to match, whether this be throwing an exception, returning a sentinel, or some other mechanism. (For simplicity, we may decide that deconstruction patterns are always total and other patterns are always partial.)</p></li>
<li><p><strong>Input and output arguments.</strong> The patterns we’ve seen so far have a target and zero or more binding variables, which can be thought of as outputs. Some patterns (such as “the target is a <code>Map</code> containing a mapping whose key is X”) may also need one or more <em>inputs</em>. This puts some stress on the syntactic expression of both the declaration and the use of a pattern, as it should be obvious on both sides which arguments are inputs and which are outputs.</p></li>
<li><p><strong>Exhaustiveness.</strong> In some cases, groups of patterns (such as <code>Optional::of</code> and <code>Optional::empty</code>) are total <em>in the aggregate</em> on a given type. It would be good if we could reflect this in the declaration, so that the compiler could see that the following switch is exhaustive:</p>
<pre><code>Optional&lt;Foo&gt; o = ...;
switch (o) {
    case Optional.empty(): ...
    case Optional.of(var foo): ...
    // Ideally, no default would be needed
}</code></pre></li>
</ul>
<h2 id="combining-patterns">Combining patterns</h2>
<p>We’ve already seen one way to combine patterns – nesting. A nested pattern:</p>
<pre><code>if (x instanceof Optional.of(Point var x, var y)) { ... }</code></pre>
<p>is equivalent to:</p>
<pre><code>if (x instanceof Optional.of(var p)
    &amp;&amp; p instanceof Point(var x, var y)) { ... }</code></pre>
<p>(Note that it is possible to express this decomposition using <code>if</code> and <code>instanceof</code>, but not currently when the pattern is used in <code>switch</code>; there are a number of possible ways to address this, which will be taken up in a separate document.)</p>
<p>Another possibly useful way to combine patterns is by AND and OR operators. Suppose we have a pattern for testing whether a map has a given key (the use-site syntax shown here is solely for purposes of exposition):</p>
<pre><code>if (m instanceof Map.withMapping(&quot;name&quot;, var name)) { ... }</code></pre>
<p>If we want to extract multiple mappings at once, we could of course use <code>&amp;&amp;</code> (if we’re in the context of an <code>if</code>):</p>
<pre><code>if (m instanceof Map.withMapping(&quot;name&quot;, var name)
    &amp;&amp; m instanceof Map.withMapping(&quot;address&quot;, var address)) { ... }</code></pre>
<p>But, we can more directly express this as an AND pattern (combination syntax chosen only for purposes of exposition):</p>
<pre><code>if (m instanceof (Map.withMapping(&quot;name&quot;, var name)
                  __AND Map.withMapping(&quot;address&quot;, var address))) { ... }</code></pre>
<p>This is somewhat more direct, eliminating the repetition of asking <code>instanceof</code> twice, but more important, allows us to use compound patterns in other pattern-aware constructs as well.</p>
<p>One of the nice properties of combining patterns (whether through nesting or through algebraic combinators) is that the compound pattern is all-or-nothing; either the whole thing matches and all the bindings are defined, or none of them are.</p>
<h3 id="a-possible-approach-for-parsing-apis">A possible approach for parsing APIs</h3>
<p>The techniques outlined so far pave the way for vastly improving APIs for decomposing aggregates like JSON documents. Taking an example from the JSONP API, the following builder code:</p>
<pre><code>JsonObject value = factory.createObjectBuilder()
     .add(&quot;firstName&quot;, &quot;John&quot;)
     .add(&quot;lastName&quot;, &quot;Smith&quot;)
     .add(&quot;age&quot;, 25)
     .add(&quot;address&quot;, factory.createObjectBuilder()
         .add(&quot;streetAddress&quot;, &quot;21 2nd Street&quot;)
         .add(&quot;city&quot;, &quot;New York&quot;)
         .add(&quot;state&quot;, &quot;NY&quot;)
         .add(&quot;postalCode&quot;, &quot;10021&quot;))
     .build();</code></pre>
<p>creates the following JSON document:</p>
<pre><code>{
    &quot;firstName&quot;: &quot;John&quot;,
    &quot;lastName&quot;: &quot;Smith&quot;,
    &quot;age&quot;: 25,
    &quot;address&quot; : {
        &quot;streetAddress&quot;: &quot;21 2nd Street&quot;,
        &quot;city&quot;: &quot;New York&quot;,
        &quot;state&quot;: &quot;NY&quot;,
        &quot;postalCode&quot;: &quot;10021&quot;
    }
}</code></pre>
<p>The builder API allowed us to construct the document cleanly, but if we wanted to parse the result, the code is far larger, uglier, and more error-prone – in part because we have to constantly stop and ask questions like “was there a key called <code>address</code>?” “Did it map to an object?” We want to express the shape of document we expect, and then have it either match, or not – all-or-nothing. One possible way to get there is by composing patterns.</p>
<p>To start with, let’s posit that we add some patterns to the API for <code>intKey</code>, <code>stringKey</code>, <code>objectKey</code>, etc, which mean "does the current object have a key that maps to this kind of value (similar to our <code>Map.withMapping</code> pattern.) Now, we could parse the above document with something like:</p>
<pre><code>switch (doc) {
    case stringKey(&quot;firstName&quot;, var first)
         __AND stringKey(&quot;lastName&quot;, var last)
         __AND intKey(&quot;age&quot;, var age)
         __AND objectKey(&quot;address&quot;,
                 stringKey(&quot;city&quot;, var city)
                 __AND stringKey(&quot;state&quot;, var state)
                 __AND ...): ...
}</code></pre>
<p>This code looks more like the document we are trying to parse, and also has the advantage that either the whole expression matches and all the bindings are defined, or none of them are.</p>
<h3 id="down-the-road-structured-patterns">Down the road: structured patterns?</h3>
<p>For each of the idioms for aggregation, we have seen that we can construct a pattern which serves as its dual. If, in some future version of Java, we added <em>collection literals</em>, this would be a new idiom for aggregation. And, as with the other forms, there is an obvious corresponding dual for destructuring.</p>
<p>Suppose, for example, we could construct a <code>Map</code> as follows (again, syntax purely for sake of exposition):</p>
<pre><code>Map&lt;String, String&gt; m = {
    &quot;name&quot; : name,
    &quot;age&quot; : age
};</code></pre>
<p>Then, we could similarly expose a <em>map pattern</em> for deconstructing it:</p>
<pre><code>if (m instanceof
    {
        &quot;name&quot;: var name,
        &quot;age&quot;: var age
    }) { ... }</code></pre>
<p>And, just as with other patterns, these compose via nesting:</p>
<pre><code>if (doc instanceof
    {
        &quot;firstName&quot;: var first,
        &quot;lastName&quot;, var last,
        &quot;age&quot;, Integer.valueOf(var age),
        &quot;address&quot; : {
             &quot;city&quot;: var city,
             &quot;state&quot;: var state
        }
    }) { ... }</code></pre>
<h3 id="flatter-apis">Flatter APIs</h3>
<p>One possible consequence of having patterns in our API toolbox is that APIs may become “flatter”. In the <code>Shape</code> example above, its conceivable that one might expose an API that has lots of public static factories that correspond to private implementation classes, and public static patterns for identifying these instances, but not exposing types for these various configurations at all. This allows APIs to use subtyping primarily as an implementation technique, but expose polymorphism through patterns rather than type hierarchies. For some APIs, this may be a perfectly sensible move.</p>
<div class="footer" id="footer">
<img src="http://openjdk.java.net/images/openjdk-small.png">
<br>© 2021 Oracle Corporation and/or its affiliates
<br><a href="http://openjdk.java.net/legal/tou/">Terms of Use</a>
· License: <a href="http://openjdk.java.net/legal/gplv2+ce.html">GPLv2</a>
· <a href="http://www.oracle.com/us/legal/privacy/">Privacy</a>
· <a href="http://www.oracle.com/us/legal/third-party-trademarks/third-party-trademarks-078568.html">Trademarks</a>
</div>
</body>
</html>
